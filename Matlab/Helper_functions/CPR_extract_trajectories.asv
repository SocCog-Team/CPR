close all

addpath /Users/fschneider/Documents/GitLab/matlab4mworks

pth             = '/Users/fschneider/Desktop/'; % '/Volumes/DPZ/KognitiveNeurowissenschaften/CNL/DATA/fxs/CPR_random_walk_social_context/Dyad3/h5/'
fname           = '20240606_anmane_CPRneutral_block3.h5';

var_import  = {
    'INFO_', ...
    'TRIAL_', ...
    'STIM_', ...
    'IO_joystickDirection', ...
    'IO_joystickStrength',...
    'IO_fixation_flag',...
    'IO_sync_16bit',...
    'IO_syncWord',...
    'IO_rewardA_ml',...
    'EYE_x_dva',...
    'EYE_y_dva',...
    '#stimDisplayUpdate'};

% Import data
d = MW_readData([pth fname], 'include', var_import, '~typeOutcomeCheck');

% Initialise variables
idx              	= [];
stim              	= [];

% Create variable-specific indices
stim.cOn          	= double(d.time(d.event == 'TRIAL_start'));
stim.cEnd         	= double(d.time(d.event == 'TRIAL_end'));

iCyc                = 5;
cycIdx            	= [];
cycIdx          	= d.time >= stim.cOn(iCyc) & d.time <= stim.cEnd(iCyc);

% Variable index
idx.RDP_dot       	= d.event == 'STIM_RDP_dotPositions';
idx.JS_dir       	= d.event == 'IO_joystickDirection';
idx.JS_str        	= d.event == 'IO_joystickStrength';
idx.JS2_dir      	= d.event == 'IO_joystickDirection2';
idx.JS2_str       	= d.event == 'IO_joystickStrength2';

% Stimulus
stim.rdp_dots     	= cell2mat(d.value(cycIdx & idx.RDP_dot));
stim.rdp_dots_ts    = d.time(cycIdx & idx.RDP_dot);
[tmp_dir, tmp_len]  = integrateDots(stim.rdp_dots);
            
% Joystick responses to stimulus
joy.js_p1_dir       = cell2mat(d.value(cycIdx & idx.JS_dir));
joy.js_p1_tlt       = cell2mat(d.value(cycIdx & idx.JS_str));
joy.js_p1_ts        = double(d.time(cycIdx & idx.JS_str));
[p1_dir, p1_tlt]    = covert_to_frames(stim.rdp_dots_ts, joy.js_p1_ts, joy.js_p1_dir, joy.js_p1_tlt);

joy.js_p2_dir       = cell2mat(d.value(cycIdx & idx.JS2_dir));
joy.js_p2_tlt       = cell2mat(d.value(cycIdx & idx.JS2_str));
joy.js_p2_ts        = double(d.time(cycIdx & idx.JS2_str));
[p2_dir, p2_tlt]    = covert_to_frames(stim.rdp_dots_ts, joy.js_p2_ts, joy.js_p2_dir, joy.js_p2_tlt);


%% PLOT %%%

close all

% Create the data
lw                          = 3;
fs                          = 20;
alph                        = .5;
sz                          = 75;
nstep                       = 10;

idx                         = [3000:4500];
idx_loop                    = [3000:nstep:4500];
n                           = length(idx);
% Plot stimulus history up to the current frame
cmap_stim = repmat(linspace(225,20,n)',1,3) ./ 256; 
cmap_p1  = [linspace(200,150,n)' linspace(200,50,n)' linspace(255,180,n)'] ./ 256;
cmap_p2  = [linspace(200,50,n)' linspace(255,180,n)' linspace(200,50,n)'] ./ 256;

% polarplot(deg2rad(tmp_dir), tmp_len, 'k'); % Plot the entire curve
for i = idx_loop
%     polarplot(deg2rad(tmp_dir(i:i+1)), tmp_len(i:i+1), ...
%         'Color', cmap(i-(idx(1)-1),:), 'LineWidth', 1.5);hold on
     ps = polarscatter(deg2rad(tmp_dir(i)), tmp_len(i), 'Marker', 'o', 'MarkerFaceAlpha',alph, 'MarkerFaceColor', cmap_stim(i-(idx(1)-1),:),'MarkerEdgeColor', cmap_stim(i-(idx(1)-1),:), 'SizeData', sz);hold on
     p1 = polarscatter(deg2rad(p1_dir(i)), p1_tlt(i), 'Marker', 'o', 'MarkerFaceAlpha',alph, 'MarkerFaceColor', cmap_p1(i-(idx(1)-1),:), 'MarkerEdgeColor',  cmap_p1(i-(idx(1)-1),:), 'SizeData', sz);hold on
     p2 = polarscatter(deg2rad(p2_dir(i)), p2_tlt(i), 'Marker', 'o', 'MarkerFaceAlpha',alph, 'MarkerFaceColor', cmap_p2(i-(idx(1)-1),:),'MarkerEdgeColor',  cmap_p2(i-(idx(1)-1),:), 'SizeData', sz);hold on  
end

ax                      = gca;
ax.ThetaZeroLocation    = 'top';
ax.ThetaDir             = 'clockwise';
ax.RLim                 = [0 1];
ax.FontSize             = fs;
ax.GridAlpha            = .5;

legend([ps p1 p2], {'Stim', 'P1','P2'}, 'Box', 'off')
print(gcf, [pth '/cpr_dyad_trajectories'], '-r500', '-dpng');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [out_js_dir, out_js_tlt] = covert_to_frames(rdp_ts, js_ts, in_js_dir, in_js_tlt)
% Build frame-wise vector for joystick data
for iFrme = 1:length(rdp_ts)
    fIdx                  	= [];
    fIdx                 	= find(js_ts < rdp_ts(iFrme),1,'last');         % Extract last entry before frame onset
    
    if sum(fIdx) == 0 || isempty(fIdx)
        out_js_dir(iFrme)	= nan;                                          % Write to vector
        out_js_tlt(iFrme)	= nan;
    else
        out_js_dir(iFrme)	= in_js_dir(fIdx);
        out_js_tlt(iFrme)	= in_js_tlt(fIdx);
    end
end
end

function [resultant, res_length] = integrateDots(dot_in)

xIdx           	= logical(mod([1:size(dot_in,1)],2));                       % Index for x/y position

for iFrme = 2:size(dot_in,2)
    clear xpos_last ypos_last xpos ypos vs ve dist dt dot_idx mdf         	% Clear temporary variables

    xpos_last           = dot_in(xIdx,iFrme-1);                             % Last frame: x-position
    ypos_last           = dot_in(~xIdx,iFrme-1);                            % Last frame: y-position
    
    xpos                = dot_in(xIdx,iFrme);                               % This frame: x-position
    ypos                = dot_in(~xIdx,iFrme);                              % This frame: y-position
    
    for iDot = 1:length(ypos)
        % Dot position
        vs(iDot,:)      = [xpos_last(iDot), ypos_last(iDot)];             	% last frame
        ve(iDot,:)    	= [xpos(iDot), ypos(iDot)];                       	% this frame
        
        % Dot speed
        dt(iDot,:)      = ve(iDot,:) - vs(iDot,:);                         	% delta
        dist(iDot)      = pdist([vs(iDot,:);ve(iDot,:)],'euclidean');     	% distance/vector length between points
    end
    
    ofs                 = .001;                                             % Arbitrary offset
    expected_speed      = (8/1000)*(1000/120);                              % Dot speed: 8dva/s; Frame rate: 120Hz = 8.333ms/frame
    
    if median(dist) < expected_speed-ofs || median(dist) > expected_speed+ofs
%         iFrme
%         median(dist)
        resultant(iFrme) = nan;
        res_length(iFrme) = nan;
        continue
    end
    
    % Index: Exclude dots that reappear elsewhere after lifetime expired
    dot_idx            	= dist >= expected_speed-ofs & dist <= expected_speed+ofs;

    %                 % Calculate direction (theta) and step size (rho => dot speed)
    %                 [theta,rho]         = cart2pol(dt(dot_idx,1),dt(dot_idx,2));
    %                 % Zero on top, clockwise rotation
    %                 theta               = -rad2deg(theta - (pi/2));
    
    % Calculate coherence by adding up vector
    mdf                	= mean(dt(dot_idx,:));                             	% Mean x/y of all dots that didn't jump
    resultant(iFrme) 	= mod(atan2d(mdf(1),mdf(2)),360);                   % Resultant vector direction [deg]
    res_length(iFrme)	= pdist([[0 0];mdf],'euclidean') ./ median(dist);   % Resultant vector length
    end
end